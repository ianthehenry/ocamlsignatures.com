{0 OCaml Syntax}

that i can never remember

{2 Fan favorites}

{[
(* ml *)
let succ ?x:(y : int = 0) () = y + 1

let foo : type a. a My_gadt.t -> unit = fun x -> ignore x

type t = { f : 'a. 'a list -> int }
]}

{2 Mutually recursive modules}

{[
(* mli *)
module rec Foo : sig
  type t = Bar of Bar.t | Nil
end and Bar : sig
  type t = Foo of Foo.t | Nil
end
]}

{[
(* ml *)
module rec Foo : sig
  type t = Bar of Bar.t | Nil
end = struct
  type t = Bar of Bar.t | Nil
end and Bar : sig
  type t = Foo of Foo.t | Nil
end = struct
  type t = Foo of Foo.t | Nil
end
]}

Recursive module definitions always require explicit signatures.

{2 For loop}

{[
(* ml *)
let sum = ref 0 in
for i = 1 to 3 do
    sum := !sum + i
done;
assert (!sum = 6)
]}

Note that the range is inclusive on both ends.

{2 Universally quantified record field}

{[
(* mli *)
type t = { f : 'a. 'a list -> int }
]}

{[
(* ml *)
type t = { f : 'a. 'a list -> int }
]}

{1 First-Class Modules}

{2 First-class module parameter (module-style)}

{[
(* mli *)
val min : (module Comparable.S with type t = 'a) -> 'a -> 'a -> 'a
]}

{[
(* ml *)
let min (type a)
  (module Compare : Comparable.S with type t = a)
  (x : a) (y : a) =
  if Compare.( < ) x y then x else y
]}

{2 First-class module parameter (value-style)}

{[
(* mli *)
val min : (module Comparable.S with type t = 'a) -> 'a -> 'a -> 'a
]}

{[
(* ml *)
let min (type a)
  (compare : (module Comparable.S with type t = a))
  (x : a) (y : a) =
  let module Compare = (val compare) in
  if Compare.( < ) x y then x else y
]}

{2 First-class module argument}

{[
(* ml *)
min (module Int) 1 2
]}

{1 Function Signatures}

{2 Annotated return type}

{[
(* mli *)
val succ : int -> int
]}

{[
(* ml *)
let succ x : int = x + 1
]}

{2 Annotated positional argument}

{[
(* mli *)
val succ : int -> int
]}

{[
(* ml *)
let succ (x : int) = x + 1
]}

{2 Annotated return type and positional argument}

{[
(* mli *)
val succ : int -> int
]}

{[
(* ml *)
let succ (x : int) : int = x + 1
]}

{2 Named argument}

{[
(* mli *)
val succ : x:int -> int
]}

{[
(* ml *)
let succ ~x = x + 1
]}

{2 Renamed argument}

{[
(* mli *)
val succ : x:int -> int
]}

{[
(* ml *)
let succ ~x:y = y + 1
]}

{2 Named argument with annotated return type}

{[
(* mli *)
val succ : x:int -> int
]}

{[
(* ml *)
let succ ~x : int = x + 1
]}

Note that the space between the identifier and the colon is significant to
disambiguate this from a renamed argument.

{2 Renamed argument with annotated return type}

{[
(* mli *)
val succ : x:int -> int
]}

{[
(* ml *)
let succ ~x:y : int = y + 1
]}

The space between the identifier and the second colon is no longer required, as
there is no more ambiguity.

{2 Annotated named argument}

{[
(* mli *)
val succ : x:int -> int
]}

{[
(* ml *)
let succ ~(x : int) = x + 1
]}

{2 Annotated renamed argument}

{[
(* mli *)
val succ : x:int -> int
]}

{[
(* ml *)
let succ ~x:(y : int) = y + 1
]}

{2 Optional argument}

{[
(* mli *)
val succ : ?x:int -> unit -> int option
]}

{[
(* ml *)
let succ ?x () = Option.map ~f:(fun n -> n + 1) x
]}

Note that optional arguments without subsequent positional arguments will
generate a compiler warning, so we add a final unit argument to get around that.
{{: https://ocaml.org/docs/labels#warning-this-optional-argument-cannot-be-erased}
See here for more information.}

{2 Optional argument with a default value}

{[
(* mli *)
val succ : ?x:int -> unit -> int
]}

{[
(* ml *)
let succ ?(x = 0) () = x + 1
]}

{2 Annotated optional argument}

{[
(* mli *)
val succ : ?x:int -> unit -> int option
]}

{[
(* ml *)
let succ ?(x : int option) () = Option.map ~f:(fun n -> n + 1) x
]}

{2 Annotated optional argument with a default value}

{[
(* mli *)
val succ : ?x:int -> unit -> int
]}

{[
(* ml *)
let succ ?(x : int = 0) () = x + 1
]}

{2 Renamed annotated optional argument with a default value}

{[
(* mli *)
val succ : ?x:int -> unit -> int
]}

{[
(* ml *)
let succ ?x:(y : int = 0) () = y + 1
]}

{2 Locally abstract type (monomorphic)}

{[
(* mli *)
val foo : 'a My_gadt.t -> unit
]}

{[
(* ml *)
let foo (type a) (x : a My_gadt.t) = ignore x
]}

You will often see type variables introduced like this so that a GADT's phantom
can vary over different branches of a match statement. {{: https://ocaml.org/manual/locallyabstract.html}
See here for more information.}

{2 Locally abstract type (polymorphic)}

{[
(* mli *)
val foo : 'a My_gadt.t -> unit
]}

{[
(* ml *)
let foo : type a. a My_gadt.t -> unit =
  fun x -> ignore x
]}

This is useful when you have a recursive GADT where the components of a value
have a different phantom type than the value
itself. {{: https://v2.ocaml.org/manual/locallyabstract.html#p:polymorpic-locally-abstract}
See here for more information.}
